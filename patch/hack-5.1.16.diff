--- shell.c.orig	2018-12-06 17:28:21.000000000 +0100
+++ shell.c	2020-09-09 22:16:54.394352578 +0200
@@ -369,6 +369,7 @@
 #endif
   volatile int locally_skip_execution;
   volatile int arg_index, top_level_arg_index;
+  char buf[21];
 #ifdef __OPENNT
   char **env;
 
@@ -457,61 +458,11 @@
   set_shell_name (argv[0]);
   shell_start_time = NOW;	/* NOW now defined in general.h */
 
-  /* Parse argument flags from the input line. */
-
-  /* Find full word arguments first. */
-  arg_index = parse_long_options (argv, arg_index, argc);
-  
-  if (want_initial_help)
-    {
-      show_shell_usage (stdout, 1);
-      exit (EXECUTION_SUCCESS);
-    }
-
-  if (do_version)
-    {
-      show_shell_version (1);
-      exit (EXECUTION_SUCCESS);
-    }
-
-  echo_input_at_read = verbose_flag;	/* --verbose given */
-
-  /* All done with full word options; do standard shell option parsing.*/
-  this_command_name = shell_name;	/* for error reporting */
-  arg_index = parse_shell_options (argv, arg_index, argc);
-
-  /* If user supplied the "--login" (or -l) flag, then set and invert
-     LOGIN_SHELL. */
-  if (make_login_shell)
-    {
-      login_shell++;
-      login_shell = -login_shell;
-    }
-
   set_login_shell ("login_shell", login_shell != 0);
 
-  if (dump_po_strings)
-    dump_translatable_strings = 1;
-
-  if (dump_translatable_strings)
-    read_but_dont_execute = 1;
-
   if (running_setuid && privileged_mode == 0)
     disable_priv_mode ();
 
-  /* Need to get the argument to a -c option processed in the
-     above loop.  The next arg is a command to execute, and the
-     following args are $0...$n respectively. */
-  if (want_pending_command)
-    {
-      command_execution_string = argv[arg_index];
-      if (command_execution_string == 0)
-	{
-	  report_error (_("%s: option requires an argument"), "-c");
-	  exit (EX_BADUSAGE);
-	}
-      arg_index++;
-    }
   this_command_name = (char *)NULL;
 
   /* First, let the outside world know about our interactive status.
@@ -522,7 +473,7 @@
 	standard input is a terminal
 	standard error is a terminal
      Refer to Posix.2, the description of the `sh' utility. */
-
+#if 0
   if (forced_interactive ||		/* -i flag */
       (!command_execution_string &&	/* No -c command and ... */
        wordexp_only == 0 &&		/* No --wordexp and ... */
@@ -533,33 +484,8 @@
     init_interactive ();
   else
     init_noninteractive ();
-
-  /*
-   * Some systems have the bad habit of starting login shells with lots of open
-   * file descriptors.  For instance, most systems that have picked up the
-   * pre-4.0 Sun YP code leave a file descriptor open each time you call one
-   * of the getpw* functions, and it's set to be open across execs.  That
-   * means one for login, one for xterm, one for shelltool, etc.  There are
-   * also systems that open persistent FDs to other agents or files as part
-   * of process startup; these need to be set to be close-on-exec.
-   */
-  if (login_shell && interactive_shell)
-    {
-      for (i = 3; i < 20; i++)
-	SET_CLOSE_ON_EXEC (i);
-    }
-
-  /* If we're in a strict Posix.2 mode, turn on interactive comments,
-     alias expansion in non-interactive shells, and other Posix.2 things. */
-  if (posixly_correct)
-    {
-      bind_variable ("POSIXLY_CORRECT", "y", 0);
-      sv_strict_posix ("POSIXLY_CORRECT");
-    }
-
-  /* Now we run the shopt_alist and process the options. */
-  if (shopt_alist)
-    run_shopt_alist ();
+#endif
+  init_noninteractive();
 
   /* From here on in, the shell must be a normal functioning shell.
      Variables from the environment are expected to be set, etc. */
@@ -568,51 +494,6 @@
   set_default_lang ();
   set_default_locale_vars ();
 
-  /*
-   * M-x term -> TERM=eterm-color INSIDE_EMACS='251,term:0.96' (eterm)
-   * M-x shell -> TERM='dumb' INSIDE_EMACS='25.1,comint' (no line editing)
-   *
-   * Older versions of Emacs may set EMACS to 't' or to something like
-   * '22.1 (term:0.96)' instead of (or in addition to) setting INSIDE_EMACS.
-   * They may set TERM to 'eterm' instead of 'eterm-color'.  They may have
-   * a now-obsolete command that sets neither EMACS nor INSIDE_EMACS:
-   * M-x terminal -> TERM='emacs-em7955' (line editing)
-   */
-  if (interactive_shell)
-    {
-      char *term, *emacs, *inside_emacs;
-      int emacs_term, in_emacs;
-
-      term = get_string_value ("TERM");
-      emacs = get_string_value ("EMACS");
-      inside_emacs = get_string_value ("INSIDE_EMACS");
-
-      if (inside_emacs)
-	{
-	  emacs_term = strstr (inside_emacs, ",term:") != 0;
-	  in_emacs = 1;
-	}
-      else if (emacs)
-	{
-	  /* Infer whether we are in an older Emacs. */
-	  emacs_term = strstr (emacs, " (term:") != 0;
-	  in_emacs = emacs_term || STREQ (emacs, "t");
-	}
-      else
-	in_emacs = emacs_term = 0;
-
-      /* Not sure any emacs terminal emulator sets TERM=emacs any more */
-      no_line_editing |= STREQ (term, "emacs");
-      no_line_editing |= in_emacs && STREQ (term, "dumb");
-
-      /* running_under_emacs == 2 for `eterm' */
-      running_under_emacs = in_emacs || STREQN (term, "emacs", 5);
-      running_under_emacs += emacs_term && STREQN (term, "eterm", 5);
-
-      if (running_under_emacs)
-	gnu_error_format = 1;
-    }
-
   top_level_arg_index = arg_index;
   old_errexit_flag = exit_immediately_on_error;
 
@@ -686,21 +567,15 @@
     arg_index = bind_args (argv, arg_index, argc, 1);	/* $1 ... $n */
 
   /* The startup files are run with `set -e' temporarily disabled. */
-  if (locally_skip_execution == 0 && running_setuid == 0)
+  /*if (locally_skip_execution == 0 && running_setuid == 0)
     {
       old_errexit_flag = exit_immediately_on_error;
       exit_immediately_on_error = 0;
 
       run_startup_files ();
       exit_immediately_on_error += old_errexit_flag;
-    }
+    }*/
 
-  /* If we are invoked as `sh', turn on Posix mode. */
-  if (act_like_sh)
-    {
-      bind_variable ("POSIXLY_CORRECT", "y", 0);
-      sv_strict_posix ("POSIXLY_CORRECT");
-    }
 
 #if defined (RESTRICTED_SHELL)
   /* Turn on the restrictions after executing the startup files.  This
@@ -723,69 +598,14 @@
   cmd_init ();		/* initialize the command object caches */
   uwp_init ();
 
-  if (command_execution_string)
-    {
-      startup_state = 2;
-
-      if (debugging_mode)
-	start_debugger ();
-
-#if defined (ONESHOT)
-      executing = 1;
-      run_one_command (command_execution_string);
-      exit_shell (last_command_exit_value);
-#else /* ONESHOT */
-      with_input_from_string (command_execution_string, "-c");
-      goto read_and_execute;
-#endif /* !ONESHOT */
-    }
-
   /* Get possible input filename and set up default_buffered_input or
      default_input as appropriate. */
-  if (shell_script_filename)
-    open_shell_script (shell_script_filename);
-  else if (interactive == 0)
-    {
-      /* In this mode, bash is reading a script from stdin, which is a
-	 pipe or redirected file. */
-#if defined (BUFFERED_INPUT)
-      default_buffered_input = fileno (stdin);	/* == 0 */
-#else
-      setbuf (default_input, (char *)NULL);
-#endif /* !BUFFERED_INPUT */
-      read_from_stdin = 1;
-    }
-  else if (top_level_arg_index == argc)		/* arg index before startup files */
-    /* "If there are no operands and the -c option is not specified, the -s
-       option shall be assumed." */
-    read_from_stdin = 1;
 
+  
+  open_shell_script (argv[0]);
   set_bash_input ();
 
-  if (debugging_mode && locally_skip_execution == 0 && running_setuid == 0 && (reading_shell_script || interactive_shell == 0))
-    start_debugger ();
-
-  /* Do the things that should be done only for interactive shells. */
-  if (interactive_shell)
-    {
-      /* Set up for checking for presence of mail. */
-      reset_mail_timer ();
-      init_mail_dates ();
-
-#if defined (HISTORY)
-      /* Initialize the interactive history stuff. */
-      bash_initialize_history ();
-      /* Don't load the history from the history file if we've already
-	 saved some lines in this session (e.g., by putting `history -s xx'
-	 into one of the startup files). */
-      if (shell_initialized == 0 && history_lines_this_session == 0)
-	load_history ();
-#endif /* HISTORY */
-
-      /* Initialize terminal state for interactive shells after the
-	 .bash_profile and .bashrc are interpreted. */
-      get_tty_state ();
-    }
+  arg_index = bind_args (argv, 1, argc, 1);
 
 #if !defined (ONESHOT)
  read_and_execute:
@@ -1520,22 +1340,6 @@
   filename = savestring (script_name);
 
   fd = open (filename, O_RDONLY);
-  if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))
-    {
-      e = errno;
-      /* If it's not in the current directory, try looking through PATH
-	 for it. */
-      path_filename = find_path_file (script_name);
-      if (path_filename)
-	{
-	  free (filename);
-	  filename = path_filename;
-	  fd = open (filename, O_RDONLY);
-	}
-      else
-	errno = e;
-    }
-
   if (fd < 0)
     {
       e = errno;
@@ -1592,6 +1396,8 @@
   /* Only do this with non-tty file descriptors we can seek on. */
   if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))
     {
+      char buf[21];
+      long long siz=0;
       /* Check to see if the `file' in `bash file' is a binary file
 	 according to the same tests done by execute_simple_command (),
 	 and report an error and exit if it is. */
@@ -1618,16 +1424,24 @@
 #endif
 	  exit (EX_NOEXEC);
 	}
-      else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
-	{
-	  internal_error (_("%s: cannot execute binary file"), filename);
-#if defined (JOB_CONTROL)
-	  end_job_control ();	/* just in case we were run as bash -i script */
-#endif
-	  exit (EX_BINARY_FILE);
-	}
-      /* Now rewind the file back to the beginning. */
-      lseek (fd, 0L, 0);
+  /*else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
+ 	{
+ 	  internal_error (_("%s: cannot execute binary file"), filename);
+ 	  exit (EX_BINARY_FILE);
+	}*/
+	    lseek(fd, -20L, SEEK_END);
+	    if (read(fd, buf, 20) != 20) {
+	      internal_error(_("%s: unable to read size"), filename);
+	      exit (EX_BADUSAGE);
+      }
+      siz = atoll(buf);
+      if (siz == 0) {
+        internal_error(_("%s: unable to get script size"), filename);
+        exit (EX_BADUSAGE);
+      }
+      lseek(fd, -21-siz, SEEK_END);
+       /* Now rewind the file back to the beginning. */
+      /*lseek (fd, 0L, 0);*/
     }
 
   /* Open the script.  But try to move the file descriptor to a randomly
